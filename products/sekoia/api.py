from datetime import datetime, timedelta
import json
from pathlib import Path
import re
import ssl
import sys
from time import sleep, time
from uuid import UUID, uuid4
from requests import HTTPError, Session
import requests
import websocket

from .utils import exclude_nones


class SekoiaAPI(Session):
    """Client for the Sekoia.io API"""

    def __init__(self, region: str, api_key: str):
        super().__init__()
        self.api_key = api_key
        self.headers.update({"Authorization": f"Bearer {api_key}"})
        region = region.lower()
        if region == "fra1":
            self.base_url = "https://api.sekoia.io"
        else:
            self.base_url = f"https://app.{region}.sekoia.io/api"

    def request(self, method, url: str, *args, **kwargs):
        url = self.base_url.strip("/") + "/" + url.strip("/")
        res = super().request(method, url, *args, **kwargs)
        try:
            res.raise_for_status()
        except HTTPError as e:
            raise ValueError(e.response.json())
        return res

    def create_intake_key(
        self,
        entity_uuid: str,
        format_uuid: str,
        name: str,
        connector_configuration: dict | None = None,
        connector_module_configuration_uuid: str | None = None,
    ):
        """Create an intake key for the given format"""
        return self.post(
            "/v1/sic/conf/intakes",
            json=exclude_nones(
                {
                    "entity_uuid": entity_uuid,
                    "format_uuid": format_uuid,
                    "name": name,
                    "connector_configuration": connector_configuration,
                    "connector_module_configuration_uuid": connector_module_configuration_uuid,
                }
            ),
        ).json()

    def delete_intake_key(self, uuid: str):
        """Delete an intake key given its UUID"""
        return self.delete(f"/v1/sic/conf/intakes/{uuid}")

    def get_intake_keys(self, name: str | None = None, format_uuid: str | None = None):
        """Return a page of intake keys"""
        return self.get(
            "/v1/sic/conf/intakes",
            params={
                "match[name]": name,
                "match[format_uuid]": format_uuid,
            },
        ).json()["items"]

    def get_entities(self):
        """Return a page of entities"""
        return self.get("/v1/sic/conf/entities").json()["items"]

    def get_or_create_main_entity(self, default_name: str = "Main Entity"):
        """Return the main entity or create it"""
        try:
            return sorted(self.get_entities(), key=lambda x: x["entity_id"])[0]
        except IndexError:
            return self.create_entity(default_name)

    def create_entity(
        self,
        name: str,
        entity_id: str | None = None,
        alerts_generation: str | None = None,
        description: str = "Generated by Meshroom",
    ):
        """Create a new entity"""
        entity_id = entity_id or name.lower().replace(" ", "_")
        alerts_generation = alerts_generation or self.get_generation_modes()[0]["uuid"]
        return self.post(
            "/v1/sic/conf/entities",
            json={
                "entity_id": entity_id,
                "description": description,
                "alerts_generation": alerts_generation,
                "name": name,
            },
        ).json()

    def get_generation_modes(self):
        """Return the available generation modes"""
        return self.get("/v1/sic/conf/generation-modes").json()["items"]

    def get_or_create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Return a default module configuration or create it for the given module UUID"""
        try:
            return self.get_module_configurations(module_uuid)[0]
        except IndexError:
            return self.create_module_configuration(module_uuid, name, settings)

    def get_module_configurations(self, module_uuid: str):
        """Return the module configurations for the given module UUID"""
        return self.get(
            "/v1/symphony/module-configurations",
            params={
                "match[module_uuid]": module_uuid,
                "with_module": "true",
            },
        ).json()["items"]

    def create_module_configuration(self, module_uuid: str, name: str, settings: dict):
        """Create a new module configuration"""
        return self.post(
            "/v1/symphony/module-configurations",
            json={
                "name": "Default",
                "module_uuid": module_uuid,
                "value": settings,
            },
        ).json()

    def list_intake_formats(self, name: str, is_custom: bool | None = None):
        """Return a list of intake formats matching the given name and is_custom status"""
        return [
            x
            for x in self.get("/v1/ingest/formats", params={"match[name]": name}).json()["items"]
            if is_custom is None or (x["community_uuid"] is not None and is_custom) or (x["community_uuid"] is None and not is_custom)
        ]

    def get_intake_format(self, uuid: str):
        """Return the intake format for the given UUID"""
        try:
            return self.get(f"/v1/ingest/formats/{uuid}")
        except Exception:
            return None

    def create_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str | None = None,
        parser: dict = {},
        slug: str | None = None,
        datasources: list[str] = [],
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Create a custom intake format"""
        f = self.post(
            "v1/ingest/formats",
            json={
                "format_uuid": uuid,
                "name": name,
                "datasources": datasources,
                "description": description or name,
                "parser": parser,
                "slug": slug or name.lower().replace(" ", "-"),
                "taxonomy": taxonomy,
                "automation_module_uuid": automation_module_uuid,
                "automation_connector_uuid": automation_connector_uuid,
            },
        ).json()
        self.post(f"v1/ingest/formats/{f['uuid']}/smart-descriptions", json={"content": smart_descriptions})
        if logo and logo.is_file():
            self.put(
                f"v1/ingest/formats/{f['uuid']}/picture",
                files={"picture": (logo.name, logo.open("rb"), "image/png")},
            )
        return f

    def update_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str,
        parser: dict = {},
        datasources: list[str] = [],
        slug: str | None = None,
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Update a custom intake format"""
        self.put(
            f"v1/ingest/formats/{uuid}",
            json={
                "name": name,
                "datasources": datasources,
                "description": description,
                "parser": parser,
                "slug": slug or name.lower().replace(" ", "-"),
                "taxonomy": taxonomy,
                "uuid": uuid,
                "automation_module_uuid": automation_module_uuid,
                "automation_connector_uuid": automation_connector_uuid,
            },
        )
        self.post(f"v1/ingest/formats/{uuid}/smart-descriptions", json={"content": smart_descriptions})
        if logo and logo.is_file():
            self.put(
                f"v1/ingest/formats/{uuid}/picture",
                files={"picture": (logo.name, logo.open("rb"), "image/png")},
            )

    def create_or_update_custom_intake_format(
        self,
        uuid: str,
        name: str,
        description: str,
        parser: dict = {},
        datasources: list[str] = [],
        slug: str | None = None,
        taxonomy: list = [],
        smart_descriptions: list = [],
        logo: Path | None = None,
        automation_module_uuid: str | None = None,
        automation_connector_uuid: str | None = None,
    ):
        """Create or update a custom intake format"""
        if self.get_intake_format(uuid):
            return self.update_custom_intake_format(uuid, name, description, parser, datasources, slug, taxonomy, smart_descriptions, logo, automation_module_uuid, automation_connector_uuid)
        else:
            return self.create_custom_intake_format(uuid, name, description, parser, slug, datasources, taxonomy, smart_descriptions, logo, automation_module_uuid, automation_connector_uuid)

    def pull_custom_integration(self, git_url: str, branch: str = "master", path: str = "", ssh_key_id: str = None):
        """Pull a custom integration from a Git repository"""
        print(f"Pulling custom integration from Git at {git_url} /{path} branch={branch} (this can take a few minutes to build the module's docker image)")
        task_uuid = self.post(
            "/v1/symphony/modules/from-git",
            json={
                "branch": branch,
                "git": git_url,
                "path": path,
                "ssh_key_id": ssh_key_id,
            },
        ).json()["task_uuid"]
        step_status = {}
        errors = []
        while True:
            sleep(2)
            print(".", end="", flush=True)
            status = self.get(f"/v1/tasks/{task_uuid}").json()
            for s in status["attributes"]["validation_steps"]:
                if step_status.get(s["name"]) != s["status"]:
                    print(f"{s['name']}: {s['status']}")
                    if s["status"] == "failed" and s.get("error"):
                        errors.append(f"{s['error']} {s.get('output', '')}")
                step_status[s["name"]] = s["status"]
            if status.get("status") == "FAILED":
                errors = "\n".join(errors)
                raise RuntimeError(f"Failed to pull the custom integration: \n{errors}")
            if status.get("status") in ("SUCCESS", "FINISHED"):
                break

    def create_ssh_key(self):
        """Create an SSH key for pulling custom integrations from Git"""
        return self.post("/v1/symphony/ssh-keys/").json()

    def get_events(self, terms: dict, earliest: datetime | None = None, latest: datetime | None = None) -> dict:
        """Return a page of events matching the given terms"""
        job = self.post(
            "v1/sic/conf/events/search/jobs",
            json={
                "term": " AND ".join([f'{k}: "{v}"' for k, v in terms.items()]),
                "earliest_time": (earliest or (datetime.utcnow() - timedelta(hours=1))).isoformat() + "Z",
                "latest_time": (latest or datetime.utcnow().isoformat()) + "Z",
                "visible": True,
                "only_eternal": False,
            },
        ).json()

        for msg in self.live_api():
            if msg.get("type") == "search-job" and msg.get("action") == "updated" and msg.get("attributes", {}).get("uuid") == job["uuid"]:
                if msg["attributes"]["updated"]["status"] == "done":
                    break

        return self.get(f"v1/sic/conf/events/search/jobs/{job['uuid']}/events?limit=50").json()

    def watch_events(self, intake_uuid: str | None = None, earliest: datetime | None = None):
        """Subscribe to events for the given intake"""
        earliest = earliest or (datetime.utcnow() - timedelta(minutes=5))
        print(f"Watching events received since {earliest} {f'on intake {intake_uuid}' if intake_uuid else ''}", file=sys.stderr)
        terms = {}
        if intake_uuid:
            terms["sekoiaio.intake.uuid"] = intake_uuid
        while True:
            evts = self.get_events(terms, earliest)["items"]
            evts = sorted(evts, key=lambda x: datetime.fromisoformat(x["timestamp"].replace("Z", "+00:00")))

            # Move the timestamp cursor one millisecond after the last received event
            try:
                earliest = (datetime.fromisoformat(evts[-1]["timestamp"].replace("Z", "+00:00")) + timedelta(milliseconds=1)).replace(tzinfo=None)
            except Exception:
                ...

            yield from evts
            sleep(2)

    def live_api(self):
        """Return a live API websocket instance"""
        return LiveApi(base_url=self.base_url, api_key=self.api_key)

    def send_event_http(self, intake_key: str, message: str):
        """Send one event to SEKOIA.IO by using the http intake transport."""
        url = "https://intake.sekoia.io"  # TODO: derive from region when not on FRA1
        return requests.post(
            url,
            json={
                "json": message,
                "intake_key": intake_key,
            },
        ).text

    def get_action_uuid(self, action: str):
        """Return a playbook action's UUID given its name or UUID"""
        try:
            return str(UUID(action))
        except Exception:
            try:
                return self.get("/v1/symphony/actions", json={"match[name]": action}).json()["items"][0]["uuid"]
            except IndexError:
                return None

    def get_playbook_uuid(self, playbook: str):
        """Return a playbook's UUID given its name or UUID"""
        try:
            return str(UUID(playbook))
        except Exception:
            try:
                return self.get("/v1/symphony/playbooks", json={"match[name]": playbook}).json()["items"][0]["uuid"]
            except IndexError:
                return None

    def get_task(self, task_id: str):
        """Return a task's status given its UUID"""
        return self.get(f"/v1/tasks/{task_id}").json()

    def get_community_uuid(self):
        """Return the community UUID of the current user"""
        return self.get("/v1/me").json()["community"]

    def list_notebooks(self):
        """Return a list of notebooks"""
        return self.get("/v1/notebooks", params={"trashed": "false"}).json()["items"]

    def get_action(self, uuid: str):
        """Return the module UUID of the current user"""
        return self.get(f"/v1/symphony/actions/{uuid}").json()

    def trigger_action(self, action_uuid: str, data: dict | None = None):
        """Trigger a playbook action"""
        print(f"Run playbook action {action_uuid} with arguments ({data})")

        action = self.get_action(action_uuid)
        accounts = self.get_module_configurations(action["module_uuid"])

        payload = {
            "account_uuid": accounts[0]["uuid"] if accounts else None,
            "notebook_uuid": self.list_notebooks()[0]["uuid"],
            "action_uuid": action_uuid,
            "slug": f"playbook_action_{time()}",
            "community_uuid": self.get_community_uuid(),
            "arguments": data or {},
        }

        res = self.post(f"/v1/notebooks/actions/{action_uuid}/run", json=payload).json()
        print("Started as task", res["task_id"])
        task_id = res["task_id"]
        uuid = res["uuid"]

        sleep(0.6)
        while self.get_task(task_id)["status"] not in ("FAILED", "FINISHED"):
            print(".", end="", flush=True)
            sleep(2)
        sleep(0.1)

        t = self.get_task(task_id)
        if t["status"] == "FAILED":
            raise ValueError(t["error"])

        return self.get(f"v1/notebooks/queries/runs/{uuid}").json()

    def trigger_playbook(self, playbook_uuid: str):
        """Trigger a playbook"""
        started_at = datetime.utcnow()
        playbook = self.get(f"/v1/symphony/playbooks/{playbook_uuid}").json()
        print(f"Run playbook {playbook['name']} ({playbook_uuid})")
        trigger_configuration_uuid = playbook["trigger_configurations"][0]["uuid"]

        self.post(
            f"/v1/symphony/trigger-configurations/{trigger_configuration_uuid}",
            json={
                "event": {
                    "alert_uuid": str(uuid4()),
                    "playbook_uuid": playbook_uuid,
                }
            },
        ).json()

        while True:
            run = self.get_playbook_run(playbook_uuid, started_at)
            nb_nodes = len(run["node_runs"])
            nb_finished = len([n for n in run["node_runs"] if n["status"] in ("finished", "error")])
            print(f"{nb_finished}/{nb_nodes} nodes finished", flush=True)
            if nb_finished >= nb_nodes:
                break
            sleep(1)

        return {n: self.get(f"/v1/symphony/node-runs/{node_run['uuid']}").json() for n, node_run in run["node_runs"].items()}

    def get_playbook_run(self, playbook_uuid: str, started_after: datetime):
        runs = self.get("/v1/symphony/playbook-runs", params={"match[playbook_uuid]": playbook_uuid}).json()
        for run in runs["items"]:
            if datetime(run["started_at"]) > started_after:
                return self.get(f"/v1/symphony/playbook-runs/{run['uuid']}").json()


class LiveApi:
    """
    A websocket LiveAPI client for Sekoia.io, allowing to iterate over liveapi notifications
    """

    def __init__(self, base_url: str = "https://app.sekoia.io", api_key: str = "", timeout: int = 3):
        # LiveAPI websocket is available at /live from the base url
        if base_url == "https://api.sekoia.io":
            self.url = "wss://live.sekoia.io"
        else:
            self.url = re.sub(r"(.*://[^/]+)(/.*)?", r"\1/live", re.sub(r"^http", "ws", base_url))
        self.api_key = api_key
        self._closed = False
        self.timeout = timeout

    def __iter__(self):
        """Iterate over the liveapi notifications"""
        ws = websocket.WebSocket(sslopt={"cert_reqs": ssl.CERT_NONE})
        ws.connect(
            self.url,
            cookie=f"access_token_cookie={self.api_key}",
        )
        try:
            ws.send('{"action": "upgrade"}')
            while not self._closed:
                ws.settimeout(0.1)
                msg = json.loads(ws.recv())
                yield msg
        except websocket.WebSocketTimeoutException:
            ws.close()

    def close(self):
        """Close the websocket connection, stopping the iteration"""
        self._closed = True
